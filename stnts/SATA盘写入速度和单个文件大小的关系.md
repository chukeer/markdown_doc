# SATA盘写入速度和单个文件大小的关系

**测试场景**：连续写入N个文件，单个文件大小为M，总量约1G。磁盘为SATA盘，文件系统为ext4

**测试程序**：单线程，每个文件写入只调用一次write操作，并且会掉用fsync将页缓存刷入磁盘设备

每次测试前，先删除上次测试写入的文件，保证测试前磁盘剩余空间一致，每次测试写入数据总量约为1G。得到以下测试数据

单个文件大小(K) | 文件大小格式化 | 磁盘写入速度(M/s) 
:--- | :--- | :----
64 | 64 | 21.871
128 | 128 | 31.347
256 | 256 | 39.528
512 | 512 | 43.138
768 | 512+256 | 28.460
896 | 512+256+128 | 32.011
960 | 512+256+128+64 | 31.442
992 | 512+256+128+64+32 | 32.028
1008 | 512+256+128+64+32+16 | 34.808
1016 | 512+256+128+64+32+16+8 | 35.892
1020 | 512+256+128+64+32+16+8+4 | 34.864
1021 | 512+256+128+64+32+16+8+4+1 | 43.003
1024 | 1024 | 41.489
1025 | 1024+1 | 28.083
1028 | 1024+4 | 27.922
1032 | 1024+8 | 28.130
1040 | 1024+16 | 28.188
1056 | 1024+32 | 27.955
1088 | 1024+64 | 28.399
1152 | 1024+128 | 29.089
1280 | 1024+256 | 25.982
1536 | 1024+512 | 28.240
1792 | 1024+512+256 | 39.187
1920 | 1024+512+256+128 | 40.834
1984 | 1024+512+256+128+64 | 45.629
2016 | 1024+512+256+128+64+32 | 41.332
2032 | 1024+512+256+128+64+32+16 | 44.067
2040 | 1024+512+256+128+64+32+16+8 | 42.079
2048 | 2048 | 44.747
2049 | 2048+1 | 34.414

这里文件大小选用的是2的幂次方和。文件系统block size为4K，即一个文件最小占用的磁盘空间为4K，可以看到单个文件在1M时写入速度达到一个较高值，然而超过1M哪怕一个block的大小，写入速度立马下降，当单个文件大小接近2M时，写入速度又慢慢恢复到1M的水平

写入速度和磁盘当前数据的扇区分布有关，由于测试时磁盘并不是一块空盘，为了验证这是否是偶然现象，换一块盘重新测试，得到以下数据

单个文件大小(K) | 文件大小格式化 | 磁盘写入速度(M/s) 
:--- | :--- | :----
64 | 64 | 24.312
128 | 128 | 34.369
256 | 256 | 40.229
512 | 512 | 42.002
768 | 512+256 | 30.641
896 | 512+256+128 | 33.813
960 | 512+256+128+64 | 36.355
992 | 512+256+128+64+32 | 36.800
1008 | 512+256+128+64+32+16 | 37.020
1016 | 512+256+128+64+32+16+8 | 37.392
1020 | 512+256+128+64+32+16+8+4 | 36.636
1021 | 512+256+128+64+32+16+8+4+1 | 46.140
1024 | 1024 | 45.406
1025 | 1024+1 | 27.519
1028 | 1024+4 | 26.888
1032 | 1024+8 | 29.296
1040 | 1024+16 | 27.063
1056 | 1024+32 | 28.721
1088 | 1024+64 | 29.491
1152 | 1024+128 | 29.254
1280 | 1024+256 | 30.156
1536 | 1024+512 | 28.555
1792 | 1024+512+256 | 40.401
1920 | 1024+512+256+128 | 42.393
1984 | 1024+512+256+128+64 | 43.615
2016 | 1024+512+256+128+64+32 | 47.850
2032 | 1024+512+256+128+64+32+16 | 47.727
2040 | 1024+512+256+128+64+32+16+8 | 47.621
2048 | 2048 | 45.318
2049 | 2048+1 | 35.158

将两次测试结果描绘成折线图，并放在一起比较

![](http://192.168.3.57/btq_test/pic/sata_disk_write_test.jpg)

两次测试数据走势基本一致

**结论**：SATA盘连续写入固定大小文件，单个文件大小在1M时——准确来说是占用磁盘空间为1M时，由于block size为4K，因此文件大小的范围应该是(1200K,1024K]——会达到较优的磁盘写入速度

### 对BitQiu的影响
bitqiu的默认shading\_size为1M，但是在storeServer进行存储时在文件尾部添加了校验数据和推送列表信息，这就导致每次写入一个Page时实际写入大小超过1M（额外信息在100字节以内），这在写入压力较大时，对磁盘的写入性能并不友好，根据前面的数据，可以猜测当shading\_size设为1023K（此时一个page占用磁盘空间为1M）时，写入速度会大大提高。不对服务端做任何修改，只调整客户端参数，采用单个客户端，4线程写入单副本，文件大小200M，shading\_size不同时的写入速度

shading_size(K) | Page实际占用磁盘大小(K) | 写入速度（M/s)
:--- | :--- | :---
1019 | 1020 | 37.510
1023 | 1024 | 39.625
1024 | 1028 | 29.934

当page实际占用磁盘超过1M时，写入速度最快

对bitqiu而言，如果想提高磁盘写入速度，必须让单个page磁盘占用为1M

目前每个page的额外信息不到100字节，其中包括数据推送列表和crc32数据，其中数据推送列表信息为临时性数据，在create page时进行存储，在write page完成之后即可删除，这部分数据可以全部放在内存中，目前storeServer挂载盘大小为3.6T，假设每个page的推送信息为50字节，按一个page大小1M计算，推送信息占用总内存为

    3.6*1024*1024*50Byte/1024/1024 = 180M 
    
全部放入内存绰绰有余，而且这些都是暂时性数据，实际需要保存在内存中的可能只有数M而已。如果重启内存数据丢失，create page之后还没写入的那些客户端在写入时会报错，这时需要重新进行选举再写入

crc32校验数据需要长期存储，即便内存能全部放下，还要考虑持久化的问题，持久化就难免涉及磁盘操作，如果在storeServer上进行这些操作，可能还会影响page的读写。crc32校验在write page时生成，只在read page时需要用到，因此可以考虑放在rootServer的redis中，客户端读取文件时会先查询page分布情况，可以在此时将page的crc32带回去，这样客户端在向storeServer读取page时将crc32传过去即可

以上为针对磁盘写入的一种优化方案，并非最佳方案

